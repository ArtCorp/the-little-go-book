# Об этой книге

## Лицензия

Маленькая книга о Go распространяется под лицензией Attribution-NonCommercial-ShareAlike 4.0 International license. Вы не должны платить за эту книгу.

Вы можете свободно копировать, распространять, изменять или публиковать книгу. Однако, я прошу чтобы вы всегда приписывали авторство книги мне, Карлу Сегину, и не использовали её в коммерческих целях.

Вы можете прочесть полный текст лицензии здесь:

<http://creativecommons.org/licenses/by-nc-sa/4.0/>

## Последняя версия

Последний исходный код этой книги доступен тут:
<http://github.com/karlseguin/the-little-go-book>

# Введение

У меня всегда было чувство на грани любви и ненависти, когда дело доходило до изучения новых языков. С одной стороны, языки имеют настолько фундаментальное значение для того, что мы делаем, что даже мелкое различие может оказать ощутимое значение. Этот *вау* эффект когда какой-то клик может оказать настолько сильное влияние на то, как вы программируете, что может предопределить ваши ожидания от других языков. С другой стороны, понимание языка является поэтапным процессом. Изучение новых ключевых слов, системы типов, стиля кодирования, а так же новых библиотек, сообществ и парадигм это много работы, которую, казалось бы сложно оправдать. По сравнению со всем остальным, что мы могли бы изучить, новые языки часто кажутся плохой инвестицией нашего времени.

Тем не менее, мы *должны* двигаться вперед. Мы *должны* делать постепенные шаги, потому что, опять же, языки являются основой того, что мы делаем. И хотя изменения являются поэтапными, они, как правило, имеют широкую область применения и влияют на продуктивность, читабельность, быстродействие, тестируемость, управление зависимостями, обработку ошибок, документацию, профилирование, сообщества, стандартные библиотеки, и так далее. 

У нас может возникнуть важный вопрос: **почему Go?** Для меня, существуют две весомые причины. Первая в том, что это относительно простой язык с относительно простой стандартной библиотекой. Во многих отношениях инкрементная природа Go является упрощением некоторых сложностей, которые были добавлены к другим языкам за последнюю пару десятилетий. Другая причина в том, что для многих разработчиков он будет дополнять их существующий арсенал.

Go был разработан в качестве системного языка (например, для операционных систем, драйверов устройств) и направлен на C и C++ разработчиков. По данным команды Go, и что верно для меня, разработчики приложений, не системные разработчики, являются основными пользователями Go. Почему? Я не могу авторитетно говорить за системных разработчиков, но те из нас, кто создает веб-сайты, сервисы, приложения для рабочего стола, и т. п. частично приходят к необходимости наличия класса систем, которые находятся где-то между системами низкого уровня и приложениями высокого уровня.

Это может быть обмен сообщениями, кеширование, тяжелые вычисления для анализа данных, утилиты командной строки, логирование или мониторинг. Я не знаю как это назвать, но в течении моей карьеры, когда растет сложность системы и параллелизм часто измеряется в десятках тысяч потоков, появляется быстро растущая потребность в пользовательских инфраструктурных системах. Вы *можете* построить систему с помощью Ruby или Python или чего-то еще (и многие это делают), но для таких типов систем выгодней использовать более жесткую систему типов и высокую производительность. Кроме того, вы можете использовать Go для разработки веб-сайтов (и многие это делают), но я по прежнему считаю что Node или Ruby с большим отрывом превосходят его для таких систем.

Есть и другие области применения, в которых Go превосходит другие языки. Например, не нужно устанавливать никаких дополнительных зависимостей при запуске скомпилированной программы на Go. Вам не нужно переживать, есть ли у ваших пользователей Ruby или установлена ли JVM, и если да, то какой версии. По этой причине Go становится все более популярным как язык для приложений командной строки и другим разновидностям утилит, которые вам необходимо распространять (например сборщик файлов логов).

Становится ясно, что изучение Go будет эффективным использованием вашего времени. Вам не нужно будет тратить много часов на изучение или хотя бы освоение Go, и в конечном итоге у вас останется что-то полезное от ваших усилий.

## Примечание автора

Я колебался писать эту книгу по нескольким причинам. Первая в том, что Go имеет солидную документацию, в частности [Effective Go](https://golang.org/doc/effective_go.html).

Вторая в моем дискомфорте при написании книги о языке. Когда я написал маленькую книгу о MongoDB (The Little MongoDB Book), можно было с уверенностью сказать, что большинство читателей поняли основы реляционных баз данных и моделирования. С маленькой книгой о Redis (The Little Redis Book) вы могли получить представление о хранилищах ключ-значение.

Когда я думаю об абзацах  и главах, которые впереди, я знаю, что буду не в состоянии сделать те же предположения. Сколько времени займет разговор об интерфейсах, зная, что для некоторых это будет новая концепция, а другим будет достаточно сказать, что *в Go есть интерфейсы*? В конечном счете, меня утешает то, что вы можете дать мне знать, если какие-то части слишком поверхностные или другие слишком подробные. Считайте это ценой за книгу.

# Приступая к работе

Если вы хотите немного поиграться с Go, вы должны посетить [Go Playground](http://play.golang.org/) которая позволяет запускать код на сайте без необходимости что-то устанавливать. Это также наиболее распространенный способ делиться кодом Go когда вам нужна помощь на форуме [Go's discussion forum](https://groups.google.com/forum/#!forum/golang-nuts) или на таких сайтах, как StackOverflow.

Установка Go проста. Вы можете установить его из исходного кода, но я предлагаю вам использовать уже скомпилированные бинарные файлы. Когда вы [перейдете на страницу загрузки](https://golang.org/dl/), вы увидите установочные файлы для различных платформ.

Давайте откажемся от них и научимся устанавливать Go самостоятельно. Как вы увидите, это не трудно. 

Кроме простых примеров, Go спроектирован для работы с вашим кодом внутри рабочего пространства. Рабочее пространство это папка которая состоит из подпапок `bin`, `pkg` и `src`. Вы могли бы заставить Go следовать вашему стилю - не нужно.

Как правило, я располагаю свои проекты внутри папки `~/code`. Например, `~/code/blog` содержит мой блог. Для Go мое рабочее пространство это `~/code/go` и мой работающий на Go блог будет в `~/code/go/src/blog`. Так как это долго печатать, я использую символическую ссылку, чтобы сделать его доступным по адресу  `~/code/blog`:

    ln -s ~/code/go/src/blog ~/code/blog

Короче говоря, создайте папку `go` с подпапкой `src` куда вы будете складывать свои проекты.

## OSX / Linux
Скачайте файл с расширением `tar.gz` для вашей платформы. Для OSX, то, что нужно, находится в файле `go#.#.#.darwin-amd64-osx10.8.tar.gz`, где `#.#.#` это последняя версия Go.

Извлеките содержимое файла в `/usr/local` с помощью команды `tar -C /usr/local -xzf go#.#.#.darwin-amd64-osx10.8.tar.gz`.

Установите две переменные среды:

  1. `GOPATH` указывает на папку с вашим рабочим пространством, для меня, это `$HOME/code/go`.
  2. Вам нужно добавить путь к исполняемым файлам Go в переменную `PATH`.

Вы можете установить их с помощью команд:

    echo 'export GOPATH=$HOME/code/go' >> $HOME/.profile
    echo 'export PATH=$PATH:/usr/local/go/bin' >> $HOME/.profile

Затем нужно активировать эти переменные. Вы можете закрыть и открыть заново ваш интерпретатор команд или выполнить `source $HOME/.profile`.

Наберите `go version` и вы должны увидеть примерно следующее: `go version go1.3.3 darwin/amd64`.

## Windows
Скачайте zip-файл с последней версией. Если у вас 64-битная система, вам нужен `go#.#.#.windows-amd64.zip`, где `#.#.#` последняя версия Go.

Распакуйте его в какую-нибудь папку. `c:\Go` будет хорошим выбором.

Установите две переменные среды:

  1. `GOPATH` указывает на папку с вашим рабочим пространством. Это может быть что-то вроде `c:\users\goku\work\go`.
  2. Добавьте `c:\Go\bin` в переменную `PATH`.

Переменные среды могут быть установлены с помощью кнопки `Environment Variables` на вкладке `Advanced` в панели управления `System`. Некоторые версии Windows отображают эту панель в пункте `Advanced System Settings` внутри панели `System`.

Откройте окно командной строки и наберите `go version`. Вы увидите что-то подобное: `go version go1.3.3 windows/amd64`.

# Глава 1 - Основы

Go компилируемый язык со статической типизацией. Он имеет C-подобный синтаксис и сборку мусора. Что это означает?

## Компиляция

Компиляция это процесс перевода исходного кода, который написали вы, в язык более низкого уровня – либо ассемблер (как в случае с Go), либо в какой-то другой промежуточный язык (как в случае с Java или C#).

С компилируемыми языками бывает неприятно работать потому, что компиляция может быть медленной. Сложно совершать быстрые итерации, если вы тратите минуты или часы в ожидании компиляции вашего кода. Скорость компиляции является одной из основных целей Go. Это хорошие новости для людей, которые работают над большими проектами, а так же для тех, кто привык быстро получать обратную связь при работе с интерпретируемыми языками.

Компилируемые языки, как правило, работают быстрее, и их исполняемые файлы могут быть выполнены без установки дополнительных зависимостей (по крайней мере это верно для таких языков, как C, C++ и Go, которые компилируются непосредственно в ассемблер).

## Статическая типизация

Статическая типизация означает, что все переменные должны быть определенного типа (int, string, bool, []byte, и т. д.). Это достигается либо путем указания типа при объявлении переменной, либо, во многих случаях, тип определяет компилятор (мы скоро увидим примеры).

Можно много говорить о статической типизации, но я считаю, что её лучше понять глядя на код. Если вы использовали языки с динамической типизацией, вам она может показаться громоздкой. Вы не ошибаетесь, но есть и преимущества, особенно когда она используется в сочетании с компиляцией. Эти две особенности нередко объединяются. Когда есть одна, обычно присутствует и другая, но это не строгое правило. Со строгой системой типов, компилятор может обнаруживать проблемы, которые выходят за рамки синтаксических ошибок, а также проводить дополнительную оптимизацию.

## C-подобный синтаксис

Говоря о том, что язык имеет C-подобный синтаксис, имеется ввиду то, что если вы уже использовали любой другой C-подобный язык как C, C++, Java, JavaScript и C#, то Go вам покажется похожим – по крайней мере на первый взгляд. Например, это значит, что `&&` используется как логическое И, `==` применяется для сравнения, `{` и `}` обозначает начало и конец области видимости, а индексы массивов начинаются с 0.

C-подобный синтаксис также имеет тенденцию к постановке точки с запятой в окончании строк и использовании скобок вокруг условий. В Go нет ни того, ни другого, хотя скобки все еще используются для разделения приоритета. Например, оператор `if` выглядит так:

```go
if name == "Leto" {
  print("the spice must flow")
}
```

Но в более сложных случаях скобки все еще полезны:

```go
if (name == "Goku" && power > 9000) || (name == "gohan" && power < 4000)  {
  print("super Saiyan")
}
```

Помимо этого, Go гораздо ближе к C, чем к C# или Java - не только с точки зрения синтаксиса, но и с точки зрения назначения. Это отражается в лаконичности и простоте языка, которая, надеюсь, будет очевидной, как только вы начнете изучать его.

## Сборка мусора

Некоторые переменные при создании имеют легко определяемую жизнь. Локальная переменная функции, например, исчезает при выходе из функции. В других случаях это не так очевидно, по крайней мере для компилятора. Например, жизнь переменной, которая была возвращена функцией или на которую ссылаются другие переменные и объекты, бывает сложно определить. Без сборки мусора задачей разработчика являлась очистка памяти от переменных там, где по их мнению они не нужны. Как? В C, вы выполняли `free(str);` для переменной.

Языки со сборщиками мусора (такие, как Ruby, Python, Java, JavaScript, C#, Go) способны отслеживать и освобождать переменные. которые больше не используются. Сборка мусора добавляет свои накладные расходы, но также устраняет ряд разрушительных ошибок.

## Запуск Go кода

Давайте начнем наше путешествие созданием простой программы и научимся её компилировать и выполнять. Откройте ваш любимый текстовый редактор и наберите следующий код:

```go
package main

func main() {
  println("it's over 9000!")
}
```

Сохраните файл с именем `main.go`. Сейчас, вы можете сохранить его где угодно; не обязательно использовать рабочее пространство Go для тривиальных примеров.

Затем откройте оболочку/командную строку и перейдите в папку, в которую вы сохранили файл. Мне для этого нужно было набрать `cd ~/code`.

Наконец, запустите программу, введя:

```
go run main.go
```

Если все работает, вы должны увидеть *it's over 9000!*.

Но подождите, что насчет этапа с компиляцией? `go run` это удобная команда, которая компилирует *и* запускает ваш код. Она использует временную директорию для сборки программы, выполняет её и затем очищает. Вы можете увидеть расположение временной папки выполнив:

```
go run --work main.go
```

Чтобы явно скомпилировать код, используйте `go build`:

```
go build main.go
```

Эта команда создаст исполняемый файл `main` который вы сможете запустить. В Linux / OSX не забудьте, что перед именем выполняемого файла нужно набрать точку и слэш: `./main`.

Во время разработки, вы можете использовать `go run` или `go build`. Однако в случае развертывания кода, вам нужно переносить бинарный файл, полученный с помощью `go build` и выполнять его.

### Main

Надеюсь код, который мы только что выполнили, был понятен. Мы создали функцию и напечатали строку с помощью встроенной функции `println`. Команда `go run` знала что выполнять потому, что у нее не было выбора? Нет, в Go точкой входа в программу является функция с именем `main` в пакете `main`.

Мы поговорим о пакетах в позже. Сейчас, когда вы сфокусированы на понимании основ Go, мы всегда будем писать наш код в пакете `main`.

Если хотите, вы можете отредактировать код и изменить имя пакета. Запустите код с помощью команды `go run` и вы получите ошибку. Затем измените имя обратно на `main`, но используйте другое имя функции. Вы должны увидеть другое сообщение об ошибке. Попробуйте сделать тоже самое используя команду `go build`. Обратите внимание на то, что код компилируется, но в нем нет точки входа чтобы запустить его. Это совершенно нормально когда вы, к примеру, создаете библиотеку.

## Импорты

Go имеет ряд встроенных функций, таких как `println`, которые могут быть использованы без упоминания. Вы не сможете зайти далеко без использования стандартной библиотеки Go и библиотек других разработчиков. В Go ключевое слово `import` используется для объявления пакета, который будет использован кодом в файле.

Давайте изменим нашу программу:

```go
package main

import (
  "fmt"
  "os"
)

func main() {
  if len(os.Args) != 2 {
    os.Exit(1)
  }
  fmt.Println("It's over ", os.Args[1])
}
```

И запустим её с помощью команды:

```
go run main.go 9000
```

Здесь мы используем два стандартных пакета Go: `fmt` и `os`. Мы также можем увидеть другую встроенную функцию `len`. `len` возвращает длину строки, или число значений в словаре, или, как мы видим здесь, число элементов в массиве. Если вам интересно, почему мы ожидаем два аргумента, это потому, что первый аргумент имеет индекс 0 – это всегда путь к текущему исполняемому файлу. (Изменить программу чтобы вывести его и убедитесь сами.)

Вы наверное заметили префикс перед именем функции, совпадающий с именем пакета, например `fmt.Println`. Это отличается от многих других языков. Мы узнаем больше о пакетах в следующих главах. Сейчас, знание того, как импортировать и использовать пакеты, уже хороший старт.

Go строго относится к импорту пакетов. Программа не будет скомпилирована, если вы импортируете пакет и не используете его. Попробуйте выполнить:

```go
package main

import (
  "fmt"
  "os"
)

func main() {
}
```

Вы должны получить две ошибки о том, что `fmt` и `os` были импортированы и не использованы. Раздражает ли это? Безусловно. Со временем вы привыкните к этому (хотя это всё равно будет раздражать). Go строг в этом плане потому, что неиспользуемые пакеты замедляют компиляцию; правда у большинства из нас не возникает проблем с этим.

Еще одна вещь, которую хотелось бы отметить, это то, что стандартная библиотека Go хорошо документирована. Вы можете взглянуть на <http://golang.org/pkg/fmt/#Println> чтобы узнать больше о функции `Println`, которую мы использовали. Можно кликнуть на заголовок и увидеть её исходный код. Также, промотайте вверх страницы, чтобы узнать больше о возможностях форматирования Go.

Если у вас нет доступа к Интернету, можно посмотреть документацию локально, выполнив команду:

```
godoc --http=:6060
```

И ввести в браузере адрес `http://localhost:6060`

## Переменные и определения

Было бы неплохо начать и закончить обзор переменных просто сказав: *вы можете объявить переменную и задать её значение с помощью x = 4.* К сожалению в Go все сложнее. Начнем наш разговор глядя на простые примеры. Затем, в следующей главе, познакомимся с ними более подробно рассматривая создание и использование структур. Тем не менее, полное понимание, возможно, займет некоторое время.

Вы можете подумать *Ого! Что тут может быть сложного?* Давайте посмотрим на несколько примеров.

Наиболее явный способ использования переменных в Go также наиболее подробный:

```go
package main

import (
  "fmt"
)

func main() {
  var power int
  power = 9000
  fmt.Printf("It's over %d\n", power)
}
```

Здесь мы определяем переменную `power` типа `int`. По умолчанию, Go присваивает переменным нулевые значения. Для целых чисел это `0`, для булевых `false`, для строк `""` и так далее. Затем, мы задаем значение `9000` для переменной `power`. Две строки кода можно объединить в одну:

```go
var power int = 9000
```

Все еще много печатать. В Go есть короткий оператор объявления переменных `:=`, с которым можно объявить тип так:

```go
power := 9000
```

Это удобно и работает и точно также с функциями:

```go
func main() {
  power := getPower()
}

func getPower() int {
  return 9001
}
```

Важно помнить, что `:=` используется для объявления переменной, а так же задания ей значения. Почему? Потому, что переменную нельзя объявить дважды (по крайней мере в той же области видимости). Если вы попытаетесь выполнить следующее, вы получите ошибку.

```go
func main() {
  power := 9000
  fmt.Printf("It's over %d\n", power)

  // COMPILER ERROR:
  // no new variables on left side of :=
  power := 9001
  fmt.Printf("It's also over %d\n", power)
}
```

Компиляция завершится с сообщением *нет новых переменных слева от :=*. Это значит, что когда переменная объявляется в первый раз, используется `:=`, но при последующих присваиваниях используется оператор `=`. В этом есть большой смысл, но может быть трудным для запоминания когда переключаться между этими операторами.

Если вы читали сообщение об ошибке внимательно, вы могли заметить, что слово *переменные* во множественном числе. Это потому, что Go позволяет присваивать несколько значений переменным (использванием `=` или `:=`):


```go
func main() {
  name, power := "Goku", 9000
  fmt.Printf("%s's power is over %d\n", name, power)
}
```

До тех пор пока переменная является новой, можно использовать `:=`. Рассмотрим пример:

```go
func main() {
  power := 1000
  fmt.Printf("default power is %d\n", power)

  name, power := "Goku", 9000
  fmt.Printf("%s's power is over %d\n", name, power)
}
```

Хотя `power` используется дважды с помощью `:=`, компилятор не будет жаловаться когда мы будем использовать эту переменную второй раз, он видит что другая переменная `name` новая и разрешает использовать `:=`. Однако, вы не можете изменить тип переменой `power`. Она была объявлена (косвенным образом) как целое число и может принимать только целочисленные значения.

Теперь, последнее что нужно знать, это то, что Go, как и в случае с импортами, не позволяет иметь в программе неиспользуемые переменные. Например,

```go
func main() {
  name, power := "Goku", 1000
  fmt.Printf("default power is %d\n", power)
}
```

не будет скомпилировано потому, что `name` была объявлена, но не используется. Как и неиспользуемые импорты это будет причинять одни расстройства, но в целом, я думаю, это улучшает чистоту кода и его читаемость.

Еще многое предстоит узнать об объявлениях и присваиваниях. А пока запомните, что когда используется `var ИМЯ ТИП` переменная объявляется с нулевым значением, `ИМЯ := ЗНАЧЕНИЕ` значение присваивается одновременно с объявлением переменной, а `ИМЯ = ЗНАЧЕНИЕ` когда присваивается значение уже объявленной переменной.

## Объявление функций 

Настало время рассказать о том, что функции могут возвращать несколько значений. Возьмем три функции: одна не возвращает значение, другая возвращает одно значение, и третья возвращает два значения.

```go
func log(message string) {
}

func add(a int, b int) int {
}

func power(name string) (int, bool) {
}
```

Последнюю можно использовать так:

```go
value, exists := power("goku")
if exists == false {
  // handle this error case
}
```

Иногда нужно только одно из возвращаемых значений. В этом случае другое значение присваивают переменной `_`:

```go
_, exists := power("goku")
if exists == false {
  // handle this error case
}
```

Это больше, чем просто договорённость. `_` – пустой идентификатор, его особенность в том, что возвращаемое значение в действительности не присваивается. Это позволяет вам использовать `_` снова и снова не зависимо от возвращаемого типа переменной.

И наконец еще кое-что, с чем вы наверняка столкнетесь при объявлении функций. Если параметры имеют одинаковый тип, можно использовать короткий синтаксис:

```go
func add(a, b int) int {

}
```

Вы будете часто использовать возможность возвращения нескольких значений. И так же часто использовать идентификатор `_` для их игнорирования. Множественные возвращаемые значения и чуть более короткий способ указания параметров не являются обязательными правилами. Тем не менее, рано или поздно вы столкнетесь с ними, поэтому важно знать о них.

## Перед тем, как продолжить

Мы рассмотрели несколько небольших отдельных кусочков, кажущихся разрозненными на данном этапе. Мы будем постепенно создавать примеры побольше, в надежде, что куски сойдутся вместе.

Если вы раньше работали с динамическим языком, сложности, связанные с типами и объявлениями, могут показаться шагом назад. Я соглашусь с вами. Для некоторых систем динамические языки являются более продуктивными.

Если вы работали со статически типизированным языком, вы, вероятно, почувствуете себя комфортно с Go. Определяемые типы и множественные возвращаемые значения выглядят изящно (хотя, конечно, они есть не только в Go). Надеюсь, когда мы узнаем больше, вы оцените чистый и лаконичный синтаксис.

# Глава 2 - Структуры

Go не является объектно-ориентированным языком (ОО-языком), таким как C++, Java, Ruby или C#. В нем нет объектов, нет наследования и многих других понятий, свойственных ОО-языкам, полиморфизма или перегрузки.

В Go есть структуры, которые могут быть связаны с методами. В Go также есть простая, но эффективная форма композиции. В целом, это приводит к более простому коду, но бывают случаи когда вам будет не хватать некоторых возможностей ООП (стоит отметить, что *композиция вместо наследования* старый лозунг и Go первый язык, который я использовал, занимающий твердую позицию по этому вопросу).

Хотя Go и не использует ООП, вы заметите много похожего между определением структуры и использованием классов. В качестве простого примера возьмем структуру `Saiyan`:

```go
type Saiyan struct {
  Name string
  Power int
}
```

Мы скоро увидим, как добавить метод к этой структуре, как вы добавляли бы методы к классам. Но перед тем, как это сделать, мы вернемся назад к объявлениям.

## Объявления и инициализация

Когда мы впервые рассматривали переменные и их объявление, мы видели только встроенные типы данных, такие как целые числа и строки. Сейчас, когда мы говорим о структурах, мы должны дополнить этот разговор, включив в него указатели.

Самый простой способ создать значение нашей структуры выглядит так:

```go
goku := Saiyan{
  Name: "Goku",
  Power: 9000,
}
```

*Примечание:* Запятая в конце каждой строки внутри структуры является обязательной, включая последнюю строку. Без нее, компилятор выдаст ошибку. Вы оцените это соглашение по требованию замыкающей запятой если вы раньше использовали какой-то язык или формат, в котором этого требования не было.

Не обязательно задавать все значения или даже какое-то одно. Обе записи являются корректными:

```go
goku := Saiyan{}

// или

goku := Saiyan{Name: "Goku"}
goku.Power = 9000
```

Точно также, как и с переменными, необъявленные поля содержат нулевые значения.

Кроме того, можно опустить имена полей и указать сразу значения в порядке их следования при объявлении структуры (хотя для верности, лучше использовать этот способ только для структур с несколькими полями):

```go
goku := Saiyan{"Goku", 9000}
```

Все из приведенных выше примеров объявляют переменную `goku` и присваивают ей значение.

Иногда нам не нужна переменная, которая напрямую связана со своим значением, а нужна переменная, которая хранит указатель на это значение. Указатель это адрес в памяти. Это то место, где можно найти фактическое значение. Это степень косвенности. Грубо говоря, между значением и указателем та же разница, что и между домом и его адресом.

Почему стоит использовать указатель вместо фактического значения? Это объясняется тем, что Go передает аргументы в функции как копии. Зная этот факт, что выведет следующий код?

```go
func main() {
  goku := Saiyan{"Goku", 9000}
  Super(goku)
  fmt.Println(goku.Power)
}

func Super(s Saiyan) {
  s.Power += 10000
}
```

Ответ 9000, а не 19000. Почему? Потому, что `Super` изменяет копию оригинального значения `goku` и таким образом изменения, сделанные в `Super` не отражаются на переданном значении. Для того, чтобы код работал как ожидается, нужно передать указатель на значение:

```go
func main() {
  goku := &Saiyan{"Goku", 9000}
  Super(goku)
  fmt.Println(goku.Power)
}

func Super(s *Saiyan) {
  s.Power += 10000
}
```

Мы сделали два изменения. Первое в том, что мы использовали оператор `&` для получения адреса. Затем мы изменили входной параметр в функции `Super`. Ожидалось значения типа `Saiyan` но теперь стал тип `*Saiyan`, где `*X` означает *указатель на значение типа X*. Очевидно, что существует связь между типами `Saiyan` и `*Saiyan`, но это все равно два разных типа.

Отметим, что мы все щее передаем копию значения переменной `goku` в `Super`, но теперь значением `goku` является адрес. И это копия того же адреса, что хранится в оригинальной переменной . Думайте об этом как о копии пути в ресторан. То, что у вас есть – это копия, но она ведет к тому же ресторану, что и оригинал.

Мы можем проверить, что это копия, изменив указатель (хотя это вероятно не то, что вы хотели бы сделать):

```go
func main() {
  goku := &Saiyan{"Goku", 9000}
  Super(goku)
  fmt.Println(goku.Power)
}

func Super(s *Saiyan) {
  s = &Saiyan{"Gohan", 1000}
}
```

Код выше снова выведет 9000. Так ведут себя многие языки, включая Ruby, Python, Java и C#. Go и в некоторой степени C#, просто делают этот факт очевидным.

Очевидно, что копирование указателя будет стоить дешевле с точки зрения ресурсов, чем копирование сложной структуры. В 64 битной системе указатель занимает 64 бита памяти. Если мы имеем структуру со множеством полей, возможно с большими строками или массивами, то создание копии будет дорогой операцией. Смысл указателей в том, что они дают общий доступ к значениям. Хотим ли мы чтобы `Super` изменил копию `goku` или вместо этого изменил общее значение `goku`?

Все это не означает, что вам всегда нужно использовать указатели. В конце этой главы, после того, как мы увидим немного больше операций со структурами, мы пересмотрим вопрос указатели-против-значения. 

## Функции в структурах

Мы можем ассоциировать метод со структурой:

```go
type Saiyan struct {
  Name string
  Power int
}

func (s *Saiyan) Super() {
  s.Power += 10000
}
```

В коде выше мы говорим, что тип `*Saiyan` это **получатель** метода `Super`. Мы можем вызвать `Super` так:

```go
goku := &Saiyan{"Goku", 9001}
goku.Super()
fmt.Println(goku.Power) // will print 19001
```

## Конструкторы

Структуры не имеют конструкторов. Вместо этого, вы создаёте функцию, которая возвращает экземпляр нужного типа (как фабрика):

```go
func NewSaiyan(name string, power int) *Saiyan {
  return &Saiyan{
    Name: name,
    Power: power,
  }
}
```

Этот шаблон направляет многих разработчиков на неверный путь. С одной стороны – это лишь небольшое изменение синтаксиса, с другой – это позволяет чувствовать себя немного менее разобщенным.

Наша фабрика не должна возвращать указатель; это абсолютно справедливо:

```go
func NewSaiyan(name string, power int) Saiyan {
  return Saiyan{
    Name: name,
    Power: power,
  }
}
```

## Поля структур

В примерах, которые мы видели ранее, структура `Saiyan` имела два поля `Name` и `Power` типа `string` и `int` соответственно. Поля могут быть любого типа, включая другие структуры и типы, которые мы еще не рассматривали, такие как: массивы, карты, интерфейсы и функции.

Например, мы могли бы расширить определение `Saiyan`:

```go
type Saiyan struct {
  Name string
  Power int
  Father *Saiyan
}
```

и инициализировали бы так:

```go
gohan := &Saiyan{
  Name: "Gohan",
  Power: 1000,
  Father: &Saiyan {
    Name: "Goku",
    Power: 9001,
    Father: nil,
  },
}
```

## Композиция

Go поддерживает композицию, которая является включением одной структуры в другую. В некоторых языках это называется трейт (trait) или примесь (mixin). Языки, которые не имеют явной поддержки механизма композиции всегда могут пойти долгим путем. В Java:

```go
public class Person {
  private string name;

  public string getName() {
    return this.name;
  }
}

public class Saiyan {
  // говорим, что Saiyan включает Person
  private Person person;

  // ме переадресуем вызов классу Person
  public string getName() {
    return this.person.getName();
  }
  ...
}
```

Это довольно утомительно. Каждый метод класса `Person` нужно продублировать в классе `Saiyan`. Go избегает этого занудства:

```go
type Person struct {
  Name string
}

func (p *Person) Introduce() {
  fmt.Printf("Hi, I'm %s\n", p.Name)
}

type Saiyan struct {
  *Person
  Power int
}

// и для использования этого:
goku := &Saiyan{
  Person: &Person{"Goku"},
  Power: 9001,
}
goku.Introduce()
```

Структура `Saiyan` имеет поле типа `*Person`. Так как мы не дали явного имени полю, мы получаем косвенный доступ к полям и методам составного типа. Однако, компилятор Go *дал* имя этому полю, что прекрасно видно:

```go
goku := &Saiyan{
  Person: &Person{"Goku"},
}
fmt.Println(goku.Name)
fmt.Println(goku.Person.Name)
```

Оба метода выведут "Goku".

Композиция лучше наслеования? Многие люди считают, что это более надежный способ делиться кодом. При использовании наследования, ваш класс тесно связан с суперклассом и в конечном итоге вы сфокусированы на иерархии, а не на поведении.

### Перегрузка

Перегрузка не является специфичной операцией для структур, она стоит адресации. Проще говоря, Go не поддерживает перегрузку. По этой причине вы увидите (и напишете) множество функций вроде `Load`, `LoadById`, `LoadByName` и так далее.

Тем не менее, поскольку неявная композиция на самом деле это трюк компилятора, мы можем "переписать" функции композитного типа. Например, наша структура `Saiyan` может иметь собственную функцию `Introduce`:

```go
func (s *Saiyan) Introduce() {
  fmt.Printf("Hi, I'm %s. Ya!\n", p.Name)
}
```

Композитная функция всегда доступна через `s.Person.Introduce()`.

## Указатели против значений

Когда вы пишете код на Go, вполне естественно задать себе вопрос:  *должен ли я использовать значение или указатель на это значение?* Есть две хорошие новости. Первая – ответ не зависит от следующих элементов, перечисленных ниже:

* Присваивание локальной переменной
* Поле в структуре
* Возвращение значения из функции
* Параметры функции
* Получатель метода

Вторая – если вы не уверены, используйте указатель.

Как мы уже видели, передача значения является хорошим способом сделать данные неизменяемыми (изменения, совершенные в функции не влияют на исходное значение). 
Иногда это тот результат которого вы хотите, но чаще это не так.

Даже если вы не собираетесь изменять данные, учитывайте стоимость создания копий больших структур. И наоборот, возможно, у вас есть маленькие структуры:

```go
type Point struct {
  X int,
  Y int,
}
```

В таких случаях стоимость копирования структуры будет смещена в пользу прямого доступа к `X` и `Y` непосредственно без какой-либо косвенности.

Опять же, это всё тонкие случаи. Если вы не производите итерацию по тысячам или десяткам тысяч таких указателей, вы, возможно, не заметите разницу.

## Перед тем как продолжить

С практической точки зрения, эта глава является введением в структуры, о том, как сделать экземпляр структуры получающий функцию и добавляет указатели в вашим знаниям о системе типов Go. В следующих главах мы будем опираться на то, что уже знаем о структурах и о том как они работают.

# Глава 3 - Карты, Массивы и Срезы

Ранее мы уже видели несколько простых структур. Настало время познакомиться с массивами, срезами и картами.

## Массивы

Если вы уже знакомы с Python, Ruby, Perl, JavaScript или PHP (и т. д.), при программировании вы скорее всего использовали *динамические массивы*. Это массивы, которые способны изменять свой размер в зависимости от хранимых в них данных. В Go, и как во многих других языках, массивы фиксированы. При объявлении массива необходимо указать его размер, после чего изменить его нельзя:

```go
var scores [10]int
scores[0] = 339
```

Массив выше может хранить до 10 очков, используя индексы от `scores[0]` до `scores[9]`. При попытке обращения к индексам, не входящим в этот диапазон, произойдет ошибка на этапе компиляции или выполнении программы.

Мы можем инициализировать массив вместе со значениями:

```go
scores := [4]int{9001, 9333, 212, 33}
```

Можно использовать `len` для получения размера массива. `range` используется для итерации по нему:

```go
for index, value := range scores {

}
```

Массивы эффективны в использовании, но жестко заданы. Часто мы не знаем заранее число используемых элементов. В таких случаях применяются срезы.

## Срезы

В Go вы редко, даже почти никогда, не будете использовать массивы напрямую. Вместо них вы будете использовать срезы. Срез – это легковесная структура, которая представляет собой часть массива. Есть несколько способов создать срез, и мы позже рассмотрим их подробнее. Первый способ является слегка измененным способом объявления массива:

```go
scores := []int{1,4,293,4,9}
```

В отличии от декларирования массива, срез объявлен без указания длины в квадратных скобках. Для того, чтобы понять их различия, давайте рассмотрим другой способ создания среза с использованием `make`:

```go
scores := make([]int, 10)
```

Мы используем `make` вместо `new` потому, что при создании среза происходит немного больше, чем просто выделение памяти (что делает `new`). В частности, мы должны выделить память для массива, а также инициализировать срез. В приведенном выше примере мы создаем срез длиной 10 и вместимостью 10. Длина – это размер среза. Вместимость – это размер лежащего в его основе массива. При использовании `make` мы можем указать эти два параметра отдельно:

```go
scores := make([]int, 0, 10)
```
Эта инструкция создает срез с длиной 0 и вместимостью 10. (Если вы были внимательны, вы могли заметить, что `make` и `len` *были* перегружены. Go – это такой язык, в котором, к разочарованию некоторых, используются возможности, недоступные разработчикам).

Для лучшего понимания взаимосвязи длины и вместимости, рассмотрим несколько примеров:

```go
func main() {
  scores := make([]int, 0, 10)
  scores[5] = 9033
  fmt.Println(scores)
}
```

Наш первый пример не работает. Почему? Потому, что срез имеет длину 0. Да, в его основе лежит массив, содержащий 10 элементов, но нам нужно явно расширить срез для получения доступа к этим элементам. Один из способов расширить срез – это `append`:

```go
func main() {
  scores := make([]int, 0, 10)
  scores = append(scores, 5)
  fmt.Println(scores) // выведет [5]
}
```

Но такой способ изменит смысл оригинального кода. Добавление элемента к срезу длинной 0 является установкой первого значения. По определённым причинам наш нерабочий код требует установки элемента по индексу 5. Чтобы это сделать, мы должны пере-срезать наш срез:

```go
func main() {
  scores := make([]int, 0, 10)
  scores = scores[0:6]
  scores[5] = 9033
  fmt.Println(scores)
}
```

Как сильно мы можем изменить размер среза? До размера его вместимости, в нашем случае это 10.

 Вы можете подумать *на самом деле это не решает проблему фиксированной длины массивов.* Оказывается, что `append` это что-то особенное. Если основной массив заполнен, создается больший массив и все значения копируются в него (также работают динамические массивы в PHP, Python, Ruby, JavaScript, ...). Поэтому пример выше использует `append`, мы должны повторно присвоить значение, которое было возвращено `append` переменной `scores`: `append` может создать новое значение, если в исходном не хватает места.

Если я скажу вам, что Go увеличивает массивы в два раза, вы сможете догадаться, что выведет данный код?

```go
func main() {
  scores := make([]int, 0, 5)
  c := cap(scores)
  fmt.Println(c)

  for i := 0; i < 25; i++ {
    scores = append(scores, i)

    // если вместимость изменена,
    // Go увеличивает массив, чтобы приспособиться к новым данным
    if cap(scores) != c {
      c = cap(scores)
      fmt.Println(c)
    }
  }
}
```

Изначальная вместимость переменной `scores` это 5. Для того, чтобы вместить 20 значений, она должна быть расширена 3 раза до вместимости в 10, 20 и наконец 40.

И как последний пример, рассмотрим:

```go
func main() {
  scores := make([]int, 5)
  scores = append(scores, 9332)
  fmt.Println(scores)
}
```

Здесь вывод будет [0, 0, 0, 0, 0, 9332]. Возможно, вы думали что получится [9332, 0, 0, 0, 0]? Для человека это выглядит логично. Но для компилятора, вы говорите: добавить значение к срезу, который уже содержит 5 значений.

В итоге, есть четыре способа инициализировать срез:

```go
names := []string{"leto", "jessica", "paul"}
checks := make([]bool, 10)
var names []string
scores := make([]int, 0, 20)
```

Когда какой использовать? Первый не требует особых объяснений. Его можно использовать когда вы заранее знаете значения массива.

Второй полезен когда вам нужно записывать значения по определенным индексам среза. Например:

```go
func extractPowers(saiyans []*Saiyans) []int {
  powers := make([]int, len(saiyans))
  for index, saiyan := range saiyans {
    powers[index] = saiyan.Power
  }
  return powers
}
```

Третий случай  – это пустой срез. Используется в сочетании с `append`, когда число элементов заранее неизвестно.

Последний способ позволяет задать изначальную вместимость; полезен когда у вас есть общее представление о том, сколько элементов вам нужно.

Даже если вы знаете размер, можно использовать `append`. Это момент по большей части зависит от ваших предпочтений:

```go
func extractPowers(saiyans []*Saiyans) []int {
  powers := make([]int, 0, len(saiyans))
  for _, saiyan := range saiyans {
    powers = append(powers, saiyan.Power)
  }
  return powers
}
```

Срезы в роли оберток массивов представляют собой мощный концепт. Во многих языках существует понятие нарезки массива. И в JavaScript и в Ruby массивы имеют метод `slice`. Вы можете получить срез в Ruby используя `[START..END]` или в Python с помощью `[START:END]`. Однако в этих языках срезы в действительности являются новыми массивами со скопированными в них значениями. Если мы возьмем Ruby, что выведет следующий код?

```ruby
scores = [1,2,3,4,5]
slice = scores[2..4]
slice[0] = 999
puts scores
```

Ответ: `[1, 2, 3, 4, 5]`. Потому, что `slice` совершенно новый массив с копией значений. Теперь рассмотрим эквивалент в Go:

```go
scores := []int{1,2,3,4,5}
slice := scores[2:4]
slice[0] = 999
fmt.Println(scores)
```

Результат: `[1, 2, 999, 4, 5]`.

Это изменяет принцип кодирования. Например несколько функций принимают номер позиции в качестве параметра. В JavaScript, если вам нужен символ в строке (да, срезы работают со строками тоже!) идущий после пятого, вам нужно написать:

```go
haystack = "the spice must flow";
console.log(haystack.indexOf(" ", 5));
```

В Go мы используем срезы:

```go
strings.Index(haystack[5:], " ")
```

В примере выше мы видим, что `[X:]` – это сокращение, которое означает *от X до конца*, а `[:X]` это короткая запись, означающая *от начала до X*. В отличие от других языков, Go здесь не поддерживает отрицательные индексы. Есди мы хотим получить все значения среза, кроме последнего, нам нужно выполнить:

```go
scores := []int{1,2,3,4,5}
scores = scores[:len(scores)-1]
```

С помощью этого способа мы можем реализовать эффективный способ удаления значения из несортированного среза:

```go
func main() {
  scores := []int{1,2,3,4,5}
  scores = removeAtIndex(scores, 2)
  fmt.Println(scores)
}

func removeAtIndex(source []int, index int) []int {
  lastIndex := len(source) - 1
  //меняем последнее значение и значение, которое хотим удалить, местами
  source[index], source[lastIndex] = source[lastIndex], source[index]
  return source[:lastIndex]
}
```

Наконец, когда мы уже достаточно знаем о срезах, давайте взглянем ещё на одну часто используемую функцию: `copy`. `copy` одна из тех функций, которая показывает как срезы влияют на способ кодирования. Обычно метод, который копирует значения из одного массива в другой имеет 5 параметров: `source`, `sourceStart`, `count`, `destination` и `destinationSource`. При работе со срезами нам нужны только два:

```go
import (
  "fmt"
  "math/rand"
  "sort"
)

func main() {
  scores := make([]int, 100)
  for i := 0; i < 100; i++ {
    scores[i] = int(rand.Int31n(1000))
  }
  sort.Ints(scores)

  worst := make([]int, 5)
  copy(worst, scores[:5])
  fmt.Println(worst)
}
```

Немного поиграйте с кодом выше. Попробуйте различные вариации. Посмотрите, что произойдет, если вы измените копирование на `copy(worst[2:4], scores[:5])`, или посмотрите, что будет если вы попытаетесь скопировать больше, чем `5` значений в `worst`?

## Карты

Карты в Go – это то, что в других языках называют хеш-таблицами или словарями. Они работают так, как и ожидается: вы определяете ключ и значение, можете получать, устанавливать и удалять значения.

Карты, как и срезы, создаются с помощью функции `make`. Давайте взглянем на пример:

```go
func main() {
  lookup := make(map[string]int)
  lookup["goku"] = 9001
  power, exists := lookup["vegeta"]

  // prints 0, false
  // 0 это значение по умолчанию для типа integer
  fmt.Println(power, exists)
}
```

Для получения количества ключей используйте `len`. Для удаления значения по определенному ключу вызывайте `delete`:

```go
// returns 1
total := len(lookup)

// ничего не возвращает, можно указывать несуществующий ключ
delete(lookup, "goku")
```

Карты увеличиваются динамически. Однако вы можете указать второй аргумент в `make` для установки начального значения:

```go
lookup := make(map[string]int, 100)
```

Если вы имеете какое-то представление о том, сколько ключей вам понадобится в карте, указание начального размера может помочь с производительностью.

Когда вам нужна карта в роли поля структуры, вы указываете её так:

```go
type Saiyan struct {
  Name string
  Friends map[string]*Saiyan
}
```

Один из способов инициализации:

```go
goku := &Saiyan{
  Name: "Goku",
  Friends: make(map[string]*Saiyan),
}
goku.Friends["krillin"] = ... //загрузить или создать Krillin
```

Существует еще один способ объявления и инициализации значений в Go. Как и `make`, этот подход является специфичным для карт и массивов. Вы можете объявить карту как составной литерал:

```go
lookup := map[string]int{
  "goku": 9001,
  "gohan": 2044,
}
```

Итерация по карте производится с помощью цикла `for` в комбинации с ключевым словом `range`:

```go
for key, value := range lookup {
  ...
}
```

Итерация по карте происходит не по порядку. Каждая итерация будет возвращать пару ключа и значения в случайном порядке.

## Указатели против значений

Мы закончили главу 2 вопросом о том, следует ли присваивать и передавать указатели или значения. Сейчас вернемся к нему говоря уже о массивах и картах. Какой способ стоит использовать?

```go
a := make([]Saiyan, 10)
//или
b := make([]*Saiyan, 10)
```

Многие разработчики считают, что  при передаче или возвращении `b` функция будет более эффективной. Тем не менее то, что передается/возвращается является копией среза, который в свою очередь является ссылкой. Таким образом в отношении передачи/возврата самого среза нет никакой разницы.

Разница будет видна когда вы изменяете значение среза или карты. В этом случае логика такая же как и в конце главы 2. Так что решение о том, объявлять ли массив указателей или массив значений, принимается исходя из того, что вы будете делать со значениями, а не с самими картами или массивами.

## Перед тем как продолжить

Массивы и карты в Go работают так же, как и в других языках. При использовании динамических массивов существуют небольшие изменения, но `append` должен избавить вас от большинства проблем. Если мы хотим выйти за пределы поверхности массивов, мы используем срезы. Срезы – мощные конструкции, оказывающие большое влияние на чистоту вашего кода.

Мы не рассмотрели несколько крайних случаев, но вам скорее всего не прийдется вникать в них так глубоко. Хотя если это и понадобится, надеюсь основы, полученные здесь, помогут вам самостоятельно разобраться в том, что происходит.

# Глава 4 - Организация кода и интерфейсы

Настало время поговорить о том, как организовывать ваш код.

## Пакеты

Для того, чтобы хранить сложные системы и библиотеки организованно, нам нужно научиться пользоваться пакетами. В Go имена пакетов следуют структуре директорий в вашем рабочем пространстве. Если мы создаём систему для покупок, вероятно мы начнем с пакета по имени "shopping" и сохраним его исходные файлы в папке `$GOPATH/src/shopping/`.

Однако не хочется хранить все подряд в одной папке. Например, возможно мы захотим вынести логику работы с базой данных в другую директорию. Для этого, мы создадим поддиректорию в `$GOPATH/src/shopping/db`. Имя пакета для файлов в этом подкаталоге будет просто `db`, но для получения доступа к ним из других пакетов, включая `shopping`, нам нужно импортировать `shopping/db`.

Другими словами, когда вы указываете пакет с помощью ключевого слова `package`, вы используете одно название, а не полную иерархию (например "shopping" или "db"). Когда вы импортируете пакет, необходимо указывать полный путь.

Давайте попробуем. Внутри папки `src` рабочего пространства Go (которое мы задали в разделе «Приступая к работе» во [введении](/little-go-book-0/)), создадим новую директорию с именем `shopping` и поддиректорию, которую назовём `db`. 

Внутри `shopping/db`, создайте файл с именем `db.go` и напишите следующий код:

```go
package db

type Item struct {
  Price float64
}

func LoadItem(id int) *Item {
  return &Item{
    Price: 9.001,
  }
}
```

Заметьте, что имя пакета совпадает с именем директории. Кроме того, очевидно, что на самом деле мы не подключаемся к базе данных. Мы просто будем использовать этот пример, чтобы показать, как организовывать код.

Теперь создайте файл с именем `pricecheck.go` внутри папки `shopping`. С таким содержанием:

```go
package shopping

import (
  "shopping/db"
)

func PriceCheck(itemId int) (float64, bool) {
  item := db.LoadItem(itemId)
  if item == nil {
    return 0, false
  }
  return item.Price, true
}
```

Этот код наталкивает на мысль, что импорт `shopping/db` почему-то так задан специально, ведь мы уже находимся в пакете/папке `shopping`. В действительности, вы импортируете `$GOPATH/src/shopping/db`, это означает, что вы так же легко можете импортировать `test/db`, если у вас есть пакет с именем `db` внутри папки `src/test` вашего рабочего пространства.

Если вы создаёте пакет, вам больше ничего не нужно знать, кроме того, что вы уже узнали. Для того, чтобы создать исполняемый файл, вам ещё нужен `main`. Я предпочитаю делать его в папке `main` внутри `shopping` с помощью файла с именем `main.go` следующего содержания:

```go
package main

import (
  "shopping"
  "fmt"
)

func main() {
  fmt.Println(shopping.PriceCheck(4343))
}
```

Вы можете запустить ваш код перейдя в проект `shopping` и набрав:

```
go run main/main.go
```

### Циклические импорты

Когда вы начнете писать более сложные системы, вы обязательно столкнётесь с циклическими импортами. Это происходит когда пакет А импортирует пакет Б, а пакет Б импортирует пакет А (непосредственно или косвенно через другой пакет). Это то, что компилятор делать не позволяет.

Давайте изменим структуру нашей системы покупок так, чтобы вызвать ошибку.

Переместите определение `Item` из `shopping/db/db.go` в `shopping/pricecheck.go`. Файл `pricecheck.go` должен выглядеть так:

```go
package shopping

import (
  "shopping/db"
)

type Item struct {
  Price float64
}

func PriceCheck(itemId int) (float64, bool) {
  item := db.LoadItem(itemId)
  if item == nil {
    return 0, false
  }
  return item.Price, true
}
```

Если вы попытаетесь запустить код, вы получите несколько ошибок в `db/db.go` о том, что `Item` не был определён. Это логично. `Item` больше не существует в пакете `db`; он был перемещен в пакет `shopping`. Нам нужно изменить файл `shopping/db/db.go` так:

```go
package db

import (
  "shopping"
)

func LoadItem(id int) *shopping.Item {
  return &shopping.Item{
    Price: 9.001,
  }
}
```
Теперь, когда вы запустите код, вы получите ошибку: *import cycle not allowed*. Мы исправим её с помощью добавления нового пакета, который будет содержать общие структуры. Директория в итоге будет выглядеть так:

```
$GOPATH/src
  - shopping
    pricecheck.go
    - db
      db.go
    - models
      item.go
    - main
      main.go
```

`pricecheck.go` всё ещё импортирует `shopping/db`, но `db.go` теперь импортирует `shopping/models` вместо `shopping`, тем самым прерывая цикл. Вам часто будет необходимо получать доступ не только к одному пакету `models`, но, возможно, к другим похожим по смыслу папкам вроде `utilities` и т. д. Важное правило использования общих пакетов заключается в том, что они не должны импортировать ничего из пакета `shopping` или его вложенных пакетов. Вскоре мы рассмотрим интерфейсы, которые помогут нам разрешить такие зависимости.

### Видимость

Go использует простое правило определения видимости типов данных и функций извне пакета. Если имя функции или типа начинается с большой буквы, то они видимы. Если с маленькой, то нет.

Это правило распространяется и на поля структур. Если поле структуры начинается с маленькой буквы, то доступ к нему получает только тот код, который находится в пределах того же пакета.

Например, если наш файл `items.go` содержит функцию, которая выглядит так:

```go
func NewItem() *Item {
  // ...
}
```

То она может быть вызвана с помощью `models.NewItem()`. Но если функцию назвать `newItem`, получить доступ к ней из другого пакета не получится.

Попробуйте изменить имя другой функции, структуры или поля из пакета `shopping`. Например, если вы измените имя поля `Price` структуры `Item` на `price`, то вы получите ошибку.

### Управление пакетами

Мы использовали команду `go` для запуска и сборки с помощью `run` и `build`, но у нее есть еще команда `get`, которая используется для получения библиотек сторонних разработчиков. `go get` поддерживает различные протоколы, но для этого примера мы получим библиотеку с сайта GitHub. Для этого вы должны установить `git` на свой компьютер.

Когда git установлен, из командной строки выполните:

```
go get github.com/mattn/go-sqlite3
```

`go get` забирает удалённые файлы и сохраняет их в вашем рабочем пространстве. Проверьте свою папку `$GOPATH/src`. В дополнении к проекту `shopping`, который создали мы, вы увидете папку `github.com`. Внутри находится папка `mattn`, а в ней папка `go-sqlite3`.

Мы только что говорили о том, как импортировать пакеты, которые лежат в вашем рабочем пространстве. Для использования нового пакета `go-sqlite3` мы импортируем его так:

```go
import (
  "github.com/mattn/go-sqlite3"
)
```
Я знаю, это выглядит как URL адрес, но на самом деле происходит импорт пакета `go-sqlite3`, который должен находиться в папке `$GOPATH/src/github.com/mattn/go-sqlite3`.

### Управление зависимостями

Команда `go get` имеет пару дополнительных хитростей. Если мы выполним `go get` внутри проекта, она просмотрит все файлы на наличие библиотек третих лиц в блоках `import` и скачает их. В некотором смысле, весь наш исходный код является чем-то вроде `Gemfile` или `package.json`.

Если вы выполните `go get -u`, произойдёт обновление пакетов (или определённого пакета при выполнении `go get -u ПОЛНОЕ_ИМЯ_ПАКЕТА`).

В конечном счете работа `go get` вам может показаться неадекватной. По той причине, что нет возможности указать конкретную ревизию, всегда будет использована последняя версия из master/head/trunk/default. Это может стать проблемой, если у вас два проекта и вам необходимы две разные версии одной библиотеки.

Чтобы избавиться от этой проблемы вы можете использовать утилиты управления зависимостями от сторонних разработчиков. Все они достаточно молоды, но две из них выглядят перспективными – [goop](https://github.com/nitrous-io/goop) и [godep](https://github.com/tools/godep). Полный список доступен на [go-wiki](https://code.google.com/p/go-wiki/wiki/PackageManagementTools).

## Интерфейсы

Интерфейс – это такой тип, который определяет описание, но не содержит реализации:

```go
type Logger interface {
  Log(message string)
}
```

Вам может показаться непонятным то, для каких целей их можно применить. Интерфейсы помогают разделять ваш код в зависимости от реализации. Например, мы можете иметь несколько разных типов, используемых для логирования:

```go
type SqlLogger struct { ... }
type ConsoleLogger struct { ... }
type FileLogger struct { ... }
```

При программировании с помощью интерфейсов вместо их конкретных реализаций, вы можете легко изменять (и тестировать) разные варианты без внесения изменений в ваш код.

Как можно использовать интерфейс? Так же как и любой другой тип, он может быть полем в структуре:

```go
type Server struct {
  logger Logger
}
```

или параметром функции (или возвращаемым значением):

```go
func process(logger Logger) {
  logger.Log("hello!")
}
```

В таких языках как C# или Java мы должны явно указывать, что класс реализует интерфейс:

```c#
public class ConsoleLogger : Logger {
  public void Logger(message string) {
    Console.WriteLine(message)
  }
}
```

В Go это происходит неявно. Если ваша структура имеет функцию с именем `Log` принимающую параметр `string` и не возвращающую значений, то она может быть использована как `Logger`. Это избавляет от подробного описания при использовании интерфейсов:

```go
type ConsoleLogger struct {}
func (l ConsoleLogger) Log(message string) {
  fmt.Println(message)
}
```

Также существует тенденция к использованию небольших и целенаправленных интерфейсов. Интерфейсов полно в стандартной библиотеке. Пакет `io` содержит целую кучу реализаций `io.Reader`, `io.Writer`, и `io.Closer`. Если вы пишете функцию, которая ожидает параметр с методом, который вы назвали `Close()`, то в качестве типа параметра лучше использовать `io.Closer` вместо вашего конкретного типа.

Интерфейсы могут использовать композицию. И интерфейсы сами по себе могут состоять из интерфейсов. Например, интерфейс `io.ReadCloser` состоит из `io.Reader` и `io.Closer`.

Наконец, интерфейсы обычно используются для предотвращения циклических импортов. Так как они не содержат реализации, они не будут иметь лишних зависимостей.

## Перед тем как продолжить

В конечном счете то, как структурировать ваш Go код в рабочем пространстве, вы поймёте после того, как напишете пару нетривиальных проектов. Главное запомнить, что существует тесная связь между именами пакетов и структурой директорий (не только в самом проекте, но и во всём рабочем пространстве). 

Путь Go в определении областей видимости очень прост и эффективен. Он просто согласован. Несколько вещей мы не рассмотрели, таких как константы и глобальные переменные, но будьте уверены, их видимость определяется по тому же правилу.

И, наконец, если вы новичок в использовании интерфейсов, вам может понадобиться некоторое время, чтобы получить какое-то представление о них. Тем не менее, когда вы впервые увидите, что функция ожидает какой-то параметр вроде `io.Reader`, мысленно поблагодарите её автора за то, что он не требует передавать ему больше чем, нужно.

# Chapter 5 - Tidbits

In this chapter, we'll talk about a miscellany of Go's feature which didn't quite fit anywhere else.

## Error Handling

Go's preferred way to deal with errors is through return values, not exceptions. Consider the `strconv.Atoi` function which takes a string and tries to convert it to an integer:

```go
package main

import(
  "fmt"
  "os"
  "strconv"
)

func main() {
  if len(os.Args) != 2 {
    os.Exit(1)
  }

  n, err := strconv.Atoi(os.Args[1])
  if err != nil {
    fmt.Println("not a valid number")
  } else {
    fmt.Println(n)
  }
}
```

You can create your own error type; the only requirement is that it fulfills the contract of the built-in `error` interface, which is:

```go
type error interface {
  Error() string
}
```

More commonly, we can create our own errors by importing the `errors` package and using it in the `New` function:

```go
import (
  "errors"
)


func process(int count) error {
  if count < 1 {
    return errors.New("Invalid count")
  }
  ...
  return nil
}
```

There's a common pattern in Go's standard library of using error variables. For example, the `io` package has an `EOF` variable which is defined as:

```go
var EOF = errors.New("EOF")
```

This is a package variable (it's defined outside of a function) which is publicly accessible (upper-case first letter). Various functions can return this error, say when we're reading from a file or STDIN. If it makes contextual sense, you should use this error, too. As consumers, we can use this singleton:

```go
package main

import (
  "fmt"
  "io"
)

func main() {
  var input int
  _, err := fmt.Scan(&input)
  if err == io.EOF {
    fmt.Println("no more input!")
  }
}
```

As a final note, Go does have `panic` and `recover` functions. `panic` is like throwing an exception while `recover` is like `catch`; they are rarely used.

## Defer

Even though Go has a garbage collector, some resources require that we explicitly release them. For example, we need to `Close()` files after we're done with them. This sort of code is always dangerous. For one thing, as we're writing a function, it's easy to forget to `Close` something that we declared 10 lines up. For another, a function might have multiple return points. Go's solution is the `defer` keyword:

```go
package main

import(
  "fmt"
  "os"
)

func main() {
  file, err := os.Open("a_file_to_read")
  if err != nil {
    fmt.Println(err)
    return
  }
  defer file.Close()
  // read the file
}
```

If you try to run the above code, you'll probably get an error (the file doesn't exist). The point is to show how `defer` works. Whatever you `defer` will be executed after the method returns, even if it does so violently. This lets you release resources near where it’s initialized and takes care of multiple return points.

## go fmt

Most programs written in Go follow the same formatting rules, namely, a tab is used to indent and braces go on the same line as their statement.

I know, you have your own style and you want to stick to it. That's what I did for a long time, but I'm glad I eventually gave in. A big reason for this is the `go fmt` command. It's easy to use and authoritative (so no one argues over meaningless preferences).

When you're inside a project, you can apply the formatting rule to it and all sub-projects via:

```
go fmt ./...
```

Give it a try. It does more than indent your code; it also aligns field declarations and alphabetically orders imports.

## Initialized If

Go supports a slightly modified if-statement, one where a value can be initiated prior to the condition being evaluated:

```go
if x := 10; count > x {
  ...
}
```

That's a pretty silly example. More realistically, you might do something like:

```go
if err := process(); err != nil {
  return err
}
```

Interestingly, while the values aren't available outside the if-statement, they are available inside any `else if` or `else`.

## Empty Interface and Conversions

In most object-oriented languages, a built-in base class, often named `object`, is the superclass for all other classes. Go, having no inheritance, doesn't have such a superclass. What it does have is an empty interface with no methods: `interface{}`. Since every type implements all 0 of the empty interface's methods, and since interfaces are implicitly implemented, every type fulfills the contract of the empty interface.

 If we wanted to, we could write an `add` function with the following signature:

```go
func add(a interface{}, b interface{}) interface{} {
  ...
}
```

To convert a variable to a specific type, you use `.(TYPE)`:

```go
return a.(int) + b.(int)
```

You also have access to a powerful type switch:

```go
switch a.(type) {
  case int:
    fmt.Printf("a is now an int and equals %d\n", a)
  case bool, string:
    // ...
  default:
    // ...
}
```

You'll see and probably use the empty interface more than you might first expect. Admittedly, it won't result in clean code. Converting values back and forth is ugly and dangerous but sometimes, in a static language, it's the only choice.

## Strings and Byte Arrays

Strings and byte arrays are closely related. We can easily convert one to the other:

```go
stra := "the spice must flow"
byts := []byte(stra)
strb := string(byts)
```

In fact, this way of converting is common across various types as well. Some functions explicitly expect an `int32` or an `int64` or their unsigned counterparts. You might find yourself having to do things like:

```go
int64(count)
```

Still, when it comes to bytes and strings, it's probably something you'll end up doing often. Do note that when you use `[]byte(X)` or `string(X)`, you're creating a copy of the data. This is necessary because strings are immutable.

Strings are made of `runes` which are unicode code points. If you take the length of a string, you might not get what you expect. The following prints 3:

    fmt.Println(len("椒"))

If you iterate over a string using `range`, you'll get runes, not bytes. Of course, when you turn a string into a `[]byte` you'll get the correct data.

## Function Type

Functions are first-class types:

```go
type Add func(a int, b int) int
```

which can then be used anywhere -- as a field type, as a parameter, as a return value.

```go
package main

import (
  "fmt"
)

type Add func(a int, b int) int

func main() {
  fmt.Println(process(func(a int, b int) int{
      return a + b
  }))
}

func process(adder Add) int {
  return adder(1, 2)
}
```

Using functions like this can help decouple code from specific implementations much like we achieve with interfaces.

## Before You Continue

We looked at various aspects of programming with Go. Most notably, we saw how error handling behaves and how to release resources such as connections and open files. Many people dislike Go's approach to error handling. It can feel like a step backwards. Sometimes, I agree. Yet, I also find that it results in code that's easier to follow. `defer` is an unusual but practical approach to resource management. In fact, it isn't tied to resource management only. You can use `defer` for any purpose, such as logging when a function exits.

Certainly, we haven't looked at all of the tidbits Go has to offer. But you should be feeling comfortable enough to tackle whatever you come across.

# Chapter 6 - Concurrency

Go is often described as a concurrent-friendly language. The reason for this is that it provides a simple syntax over two powerful mechanisms: goroutines and channels.

## Goroutines

A goroutine is similar to a thread, but it is scheduled by Go, not the OS. Code that runs in a goroutine can run concurrently with other code. Let's look at an example:

```go
package main

import (
  "fmt"
  "time"
)

func main() {
  fmt.Println("start")
  go process()
  time.Sleep(time.Millisecond * 10) // this is bad, don't do this!
  fmt.Println("done")
}

func process() {
  fmt.Println("processing")
}
```

There are a few interesting things going on here, but the most important is how we start a goroutine. We simply use the `go` keyword followed by the function we want to execute. If we just want to run a bit of code, such as the above, we can use an anonymous function. Do note that anonymous functions aren't only used with goroutines, however.

```go
go func() {
  fmt.Println("processing")
}()
```

Goroutines are easy to create and have little overhead. Multiple goroutines will end up running on the same underlying OS thread. This is often called an M:N threading model because we have M application threads (goroutines) running on N OS threads. The result is that a goroutine has a fraction of overhead (a few KB) than OS threads. On modern hardware, it's possible to have millions of goroutines.

Furthermore, the complexity of mapping and scheduling is hidden. We just say *this code should run concurrently* and let Go worry about making it happen.

If we go back to our example, you'll notice that we had to `Sleep` for a few milliseconds. That's because the main process exits before the goroutine gets a chance to execute (the process doesn't wait until all goroutines are finished before exiting). To solve this, we need to coordinate our code.

## Synchronization

Creating goroutines is trivial, and they are so cheap that we can start many; however, concurrent code needs to be coordinated. To help with this problem, Go provides `channels`. Before we look at `channels`, I think it's important to understand a little bit about the basics of concurrent programming.

Writing concurrent code requires that you pay specific attention to where and how you read and write values. In some ways, it's like programming without a garbage collector -- it requires that you think about your data from a new angle, always watchful for possible danger. Consider:

```go
package main

import (
  "fmt"
  "time"
)

var counter = 0

func main() {
  for i := 0; i < 2; i++ {
    go incr()
  }
  time.Sleep(time.Millisecond * 10)
}

func incr() {
  counter++
  fmt.Println(counter)
}
```

What do you think the output will be?

If you think the output is `1, 2` you're both right and wrong. It's true that if you run the above code, you'll very likely get that output. However, the reality is that the behavior is undefined. Why? Because we potentially have multiple (two in this case) goroutines writing to the same variable, `counter`, at the same time. Or, just as bad, one goroutine would be reading `counter` while another writes to it.

Is that really a danger? Yes, absolutely. `counter++` might seem like a simple line of code, but it actually gets broken down into multiple assembly statements -- the exact nature is dependent on the platform that you're running. It's true that, in this example, the most likely case is things will run just fine. However, another possible outcome would be that they both see `counter` when its equal to `0` and you get an output of `1, 1`. There are worse possibilities, such as system crashes or accessing arbitrary pieces of data and incrementing it!

The only concurrent thing you can safely do to a variable is to read from it. You can have as many readers are you want, but writes need to be synchronized. There are various ways to do this, including using some truly atomic operations that rely on special CPU instructions. However, the most common approach is to use a mutex:

```go
package main

import (
  "fmt"
  "time"
  "sync"
)

var (
  counter = 0
  lock sync.Mutex
)

func main() {
  for i := 0; i < 2; i++ {
    go incr()
  }
  time.Sleep(time.Millisecond * 10)
}

func incr() {
  lock.Lock()
  defer lock.Unlock()
  counter++
  fmt.Println(counter)
}
```

A mutex serializes access to the code under lock. The reason we simply define our lock as `lock sync.Mutex` is because the default value of a `sync.Mutex` is unlocked.

Seems simple enough? The example above is deceptive. There's a whole class of serious bugs that can arise when doing concurrent programming. First of all, it isn't always so obvious what code needs to be protected. While it might be tempting to use coarse locks (locks that cover a large amount of code), that undermines the very reason we're doing concurrent programming in the first place. We generally want fine locks; else, we end up with a ten-lane highway that suddenly turns into a one-lane road.

The other problem has to do with deadlocks. With a single lock, this isn't a problem, but if you're using two or more locks around the same code, it's dangerously easy to have situations where goroutineA holds lockA but needs access to lockB, while goroutineB holds lockB but needs access to lockA.

It actually *is* possible to deadlock with a single lock, if we forget to release it. This isn't as dangerous as a multi-lock deadlock (because those are *really* tough to spot), but just so you can see what happens, try running:

```go
package main

import (
  "time"
  "sync"
)

var (
  lock sync.Mutex
)

func main() {
  go func(){ lock.Lock() }()
  time.Sleep(time.Millisecond * 10)
  lock.Lock()
}
```

There's more to concurrent programming than what we've seen so far. For one thing, since we can have multiple reads at the same time, there's another common mutex called a read-write mutex. This exposes two locking functions: one to lock readers and one to lock writers.

Furthermore, part of concurrent programming isn't so much about serializing access across the narrowest possible piece of code; it's also about coordinating multiple goroutines. For example, sleeping for 10 milliseconds isn't a particularly elegant solution. What if a goroutine takes more than 10 milliseconds? What if it takes less and we're just wasting cycles? Also, what if instead of just waiting for goroutines to finish, we want to tell one *hey, I have new data for you to process!*?

These are all things that are doable without `channels`. Certainly for simpler cases, I believe you **should** use primitives such as `sync.Mutex` and `sync.RWMutex`, but as we'll see in the next section, `channels` aim at making concurrent programming cleaner and less error-prone.

## Channels

The challenge with concurrent programming stems from sharing data. If your goroutines share no data, you needn't worry about synchronizing them. That isn't an option for all systems, however. In fact, many systems are built with the exact opposite goal in mind: to share data across multiple requests. An in-memory cache or a database, are good examples of this. This is becoming an increasingly common reality.

Channels help make concurrent programming saner by taking shared data out of the picture. A channel is a communication pipe between goroutines which is used to pass data. In other words, a goroutine that has data can pass it to another goroutine via a channel. The result is that, at any point in time, only one goroutine has access to the data.

A channel, like everything else, has a type. This is the type of data that we'll be passing through our channel. For example, to create a channel which can be used to pass an integer around, we'd do:

```go
c := make(chan int)
```

The type of this channel is `chan int`. Therefore, to pass this channel to a function, our signature looks like:

```go
func worker(c chan int) { ... }
```

Channels support two operations: receiving and sending. We send to a channel by doing:

```
CHANNEL <- DATA
```

and receive from one by doing

```
VAR := <- CHANNEL
```

The arrow points in the direction that data flows. When sending, the data flows into the channel. When receiving, the data flows out of the channel.

The final thing to know before we look at our first example is that receiving and sending to and from a channel is blocking. That is, when we receive from a channel, execution of the goroutine won't continue until data is available. Similarly, when we send to a channel, execution won't continue until the data is received.

Consider a system with incoming data that we want to handle in separate goroutines. This is a common requirement. If we did our data-intensive processing on the goroutine which accepts the incoming data, we'd risk timing out clients. First, we'll write our worker. This could be a simple function, but I'll make it part of a structure since we haven't seen goroutines used like this before:

```go
type Worker struct {
  id int
}

func (w Worker) process(c chan int) {
  for {
    data := <- c
    fmt.Printf("worker %d got %d\n", w.id, data)
  }
}
```

Our worker is simple. It waits until data is available then "processes" it. Dutifully, it does this in a loop, forever waiting for more data to process.

To use this, the first thing we'd do is start some workers:

```go
c := make(chan int)
for i := 0; i < 4; i++ {
  worker := Worker{id: i}
  go worker.process(c)
}
```

And then we can give them some work:

```go
for {
  c <- rand.Int()
  time.Sleep(time.Millisecond * 50)
}
```

Here's the complete code to make it run:

```go
package main

import (
  "fmt"
  "time"
  "math/rand"
)

func main() {
  c := make(chan int)
  for i := 0; i < 5; i++ {
    worker := &Worker{id: i}
    go worker.process(c)
  }

  for {
    c <- rand.Int()
    time.Sleep(time.Millisecond * 50)
  }
}

type Worker struct {
  id int
}

func (w *Worker) process(c chan int) {
  for {
    data := <- c
    fmt.Printf("worker %d got %d\n", w.id, data)
  }
}
```

We don't know which worker is going to get what data. What we do know, what Go guarantees, is that the data we send to a channel will only be received by a single receiver.

Notice that the only shared state is the channel, which we can safely receive from and send to concurrently. Channels provide all of the synchronization code we need and also ensure that, at any given time, only one goroutine has access to a specific piece of data.

### Buffered Channels

Given the above code, what happens if we have more data coming in than we can handle? You can simulate this by changing the worker to sleep after it has received data:

```go
for {
  data := <- c
  fmt.Printf("worker %d got %d\n", w.id, data)
  time.Sleep(time.Millisecond * 500)
}
```

What's happening is that our main code, the one that accepts the user's incoming data (which we just simulated with a random number generator) is blocking as it sends to the channel because no receiver is available.

In cases where you need high guarantees that the data is being processed, you probably will want to start blocking the client. In other cases, you might be willing to loosen those guarantees. There are a few popular strategies to do this. The first is to buffer the data. If no worker is available, we want to temporarily store the data in some sort of queue. Channels have this buffering capability built-in. When we created our channel with `make`, we can give our channel a length:

```go
c := make(chan int, 100)
```

You can make this change, but you'll notice that the processing is still choppy. Buffered channels don't add more capacity; they merely provide a queue for pending work and a good way to deal with a sudden spike. In our example, we're continuously pushing more data than our workers can handle.

Nevertheless, we can get a sense that the buffered channel is, in fact, buffering by looking at the channel's `len`:

```go
for {
  c <- rand.Int()
  fmt.Println(len(c))
  time.Sleep(time.Millisecond * 50)
}
```

You can see that it grows and grows until it fills up, at which point sending to our channel start to block again.

### Select

Even with buffering, there comes a point where we need to start dropping messages. We can't use up an infinite amount of memory hoping a worker frees up. For this, we use Go's `select`.

Syntactically, `select` looks a bit like a switch. With it, we can provide code for when the channel isn't available to send to. First, let's remove our channel's buffering so that we can clearly see how `select` works:

```go
c := make(chan int)
```

Next, we change our `for` loop:

```go
for {
  select {
  case c <- rand.Int():
    //optional code here
  default:
    //this can be left empty to silently drop the data
    fmt.Println("dropped")
  }
  time.Sleep(time.Millisecond * 50)
}
```

We're pushing out 20 messages per second, but our workers can only handle 10 per second; thus, half the messages get dropped.

This is only the start of what we can accomplish with `select`. A main purpose of select is to manage multiple channels. Given multiple channels, `select` will block until the first one becomes available. If no channel is available, `default` is executed if one is provided. A channel is randomly picked when multiple are available.

It's hard to come up with a simple example that demonstrates this behavior as it's a fairly advanced feature. The next section might help illustrate this though.

### Timeout

We've looked at buffering messages as well as simply dropping them. Another popular option is to timeout. We're willing to block for some time, but not forever. This is also something easy to achieve in Go. Admittedly, the syntax might be hard to follow but it's such a neat and useful feature that I couldn't leave it out.

To block for a maximum amount of time, we can use the `time.After` function. Let's look at it then try to peek beyond the magic. To use this, our sender becomes:

```go
for {
  select {
  case c <- rand.Int():
  case <-time.After(time.Millisecond * 100):
    fmt.Println("timed out", )
  }
  time.Sleep(time.Millisecond * 50)
}
```

`time.After` returns a channel, so we can `select` from it. The channel is written to after the specified time expires. That's it. There's nothing more magical than that. If you're curious, here's what an implementation of `after` could look like:

```go
func after(d time.Duration) chan bool {
  c := make(chan bool)
  go func() {
    time.Sleep(d)
    c <- true
  }()
  return c
}
```

Back to our `select`, there are a couple of things to play with. First, what happens if you add the `default` case back? Can you guess? Try it. If you aren't sure what's going on, remember that `default` fires immediately if no channel is available.

Also, `time.After` is a channel of type `chan time.Time`. In the above example, we simply discard the value that was sent to the channel. If you want though, you can receive it:

```go
case t := <- time.After(time.Millisecond * 100):
  fmt.Println("timed out at", t)
```

Pay close attention to our `select`. Notice that we're sending to `c` but receiving from `time.After`. `select` works the same regardless of whether we're receiving from, sending to, or any combination of channels:

* The first available channel is chosen.
* If multiple channels are available, one is randomly picked.
* If no channel is available, the default case is executed.
* If there's no default, select blocks.

Finally, it's common to see a `select` inside a `for`. Consider:

```go
for {
  select {
  case data := <-c:
    fmt.Printf("worker %d got %d\n", w.id, data)
  case <-time.After(time.Millisecond * 10):
    fmt.Println("Break time")
    time.Sleep(time.Second)
  }
}
```

## Before You Continue

If you're new to the world of concurrent programming, it might all seem rather overwhelming. It categorically demands considerably more attention and care. Go aims to make it easier.

Goroutines effectively abstract what's needed to run concurrent code. Channels help eliminate some serious bugs that can happen when data is shared by eliminating the sharing of data. This doesn't just eliminate bugs, but it changes how one approaches concurrent programming. You start to think about concurrency with respect to message passing, rather than dangerous areas of code.

Having said that, I still make extensive use of the various synchronization primitives found in the `sync` and `sync/atomic` packages. I think it's important to be comfortable with both. I encourage you to first focus on channels, but when you see a simple example that needs a short-lived lock, consider using a mutex or read-write mutex.

# Conclusion

I recently heard Go described as a *boring* language. Boring because it's easy to learn, easy to write and, most importantly, easy to read. Perhaps, I did this reality a disservice. We *did* spend three chapters talking about types and how to declare variables after all.

If you have a background in a statically typed language, much of what we saw was probably, at best, a refresher. That Go makes pointers visible and that slices are thin wrappers around arrays probably isn't overwhelming to seasoned Java or C# developers.

If you've mostly been making use of dynamic languages, you might feel a little different. It *is* a fair bit to learn. Not least of which is the various syntax around declaration and initialization. Despite being a fan of Go, I find that for all the progress towards simplicity, there's something less than simple about it. Still, it comes down to some basic rules (like you can only declare variable once and `:=` does declare the variable) and fundamental understanding (like `new(X)` or `&X{}` only allocate memory, but slices, maps and channels require more initialization and thus, `make`).

Beyond this, Go gives us a simple but effective way to organize our code. Interfaces, return-based error handling, `defer` for resource management and a simple way to achieve composition.

Last but not least is the built-in support for concurrency. There's little to say about goroutines other than they’re effective and simple (simple to use anyway). It's a good abstraction. Channels are more complicated. I always think it's important to understand basics before using high-level wrappers. I *do* think learning about concurrent programming without channels is useful. Still, channels are implemented in a way that, to me, doesn't feel quite like a simple abstraction. They are almost their own fundamental building block. I say this because they change how you write and think about concurrent programming. Given how hard concurrent programming can be, that is definitely a good thing.
